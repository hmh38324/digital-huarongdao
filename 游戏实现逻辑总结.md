# 完美拼图游戏实现逻辑总结

> 本文档详细总结了这个华容道游戏的完整实现逻辑，包括前端、后端、数据库设计、API接口等，方便其他chat直接读取并帮助实现类似功能。

## 项目概述

这是一个基于Web的华容道拼图游戏，具有用户登录、排行榜、设置管理等功能。采用前后端分离架构，前端为纯静态页面，后端使用Cloudflare Worker + D1数据库 + KV存储。

## 技术栈

- **前端**: HTML5 + CSS3 + JavaScript (ES6+)
- **后端**: Cloudflare Worker (TypeScript)
- **数据库**: Cloudflare D1 (SQLite)
- **缓存**: Cloudflare KV
- **部署**: Cloudflare Pages + Workers

## 核心功能模块

### 1. 用户登录系统
- 基于工号+姓名的简单验证
- 用户数据存储在 `people.json` 文件中
- 支持登录状态管理和用户信息显示

### 2. 游戏核心逻辑
- 3×3拼图棋盘，右上角为空白位置
- 点击相邻图片块进行移动
- 自动计时系统（首次移动开始计时）
- 胜利条件检测

### 3. 排行榜系统
- 实时排行榜显示
- 按时间+步数排序
- 支持每用户最佳成绩记录
- 剩余尝试次数显示

### 4. 尝试次数限制
- 每用户最多3次尝试机会
- 基于KV存储的实时计数
- 防止重复开局

### 5. 管理后台
- 密码保护的管理界面
- 清空排行榜功能
- 编辑用户成绩和次数
- 导出CSV数据

## 详细实现逻辑

### 前端架构 (index.html)

#### 核心类: PuzzleGame
```javascript
class PuzzleGame {
    constructor() {
        // 游戏状态
        this.pieces = [];
        this.emptyIndex = 2; // 右上角空白位置
        this.moveCount = 0;
        this.isGameWon = false;
        
        // 用户状态
        this.isLoggedIn = false;
        this.currentUser = null;
        this.peopleData = null;
        
        // 计时系统
        this.hasTimerRunning = false;
        this.timerStartMs = null;
        this.elapsedMs = 0;
        this.timerInterval = null;
        
        // 尝试次数管理
        this.hasAttemptRecorded = false;
        this.maxAttempts = 3;
        this.currentAttemptId = null;
        
        // 图片资源
        this.pieceImages = [
            'split_images/liqun_part_1_1.png',
            'split_images/liqun_part_1_2.png',
            null, // 右上角空白
            'split_images/liqun_part_2_1.png',
            'split_images/liqun_part_2_2.png',
            'split_images/liqun_part_2_3.png',
            'split_images/liqun_part_3_1.png',
            'split_images/liqun_part_3_2.png',
            'split_images/liqun_part_3_3.png'
        ];
    }
}
```

#### 关键方法

**1. 游戏初始化**
```javascript
async loadPeopleData() {
    // 加载用户数据
    const response = await fetch('people.json');
    this.peopleData = await response.json();
    this.init();
}

init() {
    this.createPuzzle();
    this.renderPuzzle();
    this.updateUserInfo();
    // 延迟自动打乱
    setTimeout(() => {
        this.shufflePuzzle();
    }, 500);
}
```

**2. 拼图移动逻辑**
```javascript
movePiece(index) {
    if (this.isGameWon) return;
    
    // 检查登录状态
    if (!this.isLoggedIn) {
        alert('请先登录才能开始游戏！');
        return;
    }
    
    // 首次移动前登记尝试
    if (!this.hasAttemptRecorded) {
        const ok = await this.beginAttemptIfAllowed();
        if (!ok) return;
        this.hasAttemptRecorded = true;
    }
    
    // 检查移动合法性
    const emptyIndex = this.pieceImages.indexOf(null);
    if (this.canMove(index, emptyIndex)) {
        this.startTimerIfNeeded(); // 启动计时
        // 交换位置
        [this.pieceImages[index], this.pieceImages[emptyIndex]] = 
        [this.pieceImages[emptyIndex], this.pieceImages[index]];
        
        this.moveCount++;
        this.renderPuzzle();
        this.checkWin();
    }
}
```

**3. 胜利检测**
```javascript
checkWin() {
    let isCorrect = true;
    for (let i = 0; i < 9; i++) {
        if (i === 2) {
            // 位置2（右上角）应该是空的
            if (this.pieceImages[i] !== null) {
                isCorrect = false;
                break;
            }
        } else {
            // 其他位置应该有正确的图片
            const expectedRow = Math.floor(i/3) + 1;
            const expectedCol = (i%3) + 1;
            const expectedImage = `split_images/liqun_part_${expectedRow}_${expectedCol}.png`;
            
            if (this.pieceImages[i] !== expectedImage) {
                isCorrect = false;
                break;
            }
        }
    }
    
    if (isCorrect) {
        this.isGameWon = true;
        this.stopTimer();
        this.updateLeaderboard();
        setTimeout(() => {
            this.showWinMessage();
        }, 2000);
    }
}
```

**4. 用户登录**
```javascript
login(employeeId, employeeName) {
    if (this.validateLogin(employeeId, employeeName)) {
        this.isLoggedIn = true;
        this.currentUser = { 工号: employeeId, 姓名: employeeName };
        this.updateUserInfo();
        this.updateRemainingAttemptsUI();
        this.closeLoginModal();
        return true;
    }
    return false;
}

validateLogin(employeeId, employeeName) {
    if (!this.peopleData) return false;
    
    return this.peopleData.some(person => 
        person.工号 === employeeId && person.姓名 === employeeName
    );
}
```

**5. 尝试次数管理**
```javascript
async beginAttemptIfAllowed() {
    const userId = this.currentUser.工号;
    const nickname = this.currentUser.姓名;
    
    try {
        const resp = await fetch(`${WORKER_BASE_URL}/begin`, {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ userId, nickname })
        });
        
        const data = await resp.json();
        if (!resp.ok || !data.ok) {
            alert('本用户可用次数已用完（最多3次）。');
            return false;
        }
        
        this.currentAttemptId = `${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
        return true;
    } catch (e) {
        alert('网络异常，请稍后重试');
        return false;
    }
}
```

**6. 成绩提交**
```javascript
async updateLeaderboard() {
    if (!this.isLoggedIn || !this.currentUser) return;
    
    const userId = this.currentUser.工号;
    const nickname = this.currentUser.姓名;
    const moves = this.moveCount;
    const timeMs = this.elapsedMs;
    
    try {
        await fetch(`${WORKER_BASE_URL}/submit`, {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ userId, nickname, moves, timeMs })
        });
        
        this.completeAttempt({ name: nickname, timeMs, steps: moves, timestamp: new Date().toISOString() });
        this.updateRemainingAttemptsUI();
    } catch (e) {
        alert('提交成绩失败，请稍后重试');
    }
}
```

### 后端架构 (worker/src/index.ts)

#### 环境配置
```typescript
export interface Env {
  DB: D1Database;
  CACHE: KVNamespace;
  ALLOWED_ORIGINS: string; // 允许的前端域名
}

const MAX_ATTEMPTS = 3;
const ADMIN_PASSWORD = "1314520";
```

#### 数据库设计 (schema.sql)
```sql
CREATE TABLE IF NOT EXISTS scores (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  nickname TEXT NOT NULL,
  moves INTEGER NOT NULL,
  time_ms INTEGER NOT NULL,
  created_at INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_rank ON scores (moves ASC, time_ms ASC, created_at ASC);
```

#### API接口实现

**1. 排行榜接口**
```typescript
if (url.pathname === "/leaderboard" && req.method === "GET") {
  const limit = Math.min(parseInt(url.searchParams.get("limit") || "50", 10), 100);
  
  // 从D1获取每用户最佳成绩
  const { results: d1Rows } = await env.DB.prepare(
    `WITH ranked AS (
       SELECT 
         s.user_id AS userId,
         s.nickname AS nickname,
         s.moves AS moves,
         s.time_ms AS timeMs,
         s.created_at AS createdAt,
         ROW_NUMBER() OVER (PARTITION BY s.user_id ORDER BY s.time_ms ASC, s.moves ASC, s.created_at ASC) AS rn,
         COUNT(*) OVER (PARTITION BY s.user_id) AS completedCount
       FROM scores s
     )
     SELECT userId, nickname, moves, timeMs, createdAt, completedCount
     FROM ranked
     WHERE rn = 1
     ORDER BY timeMs ASC, moves ASC, createdAt ASC
     LIMIT ?`
  ).bind(limit).all();

  // 从KV获取尝试次数
  const kvKeys = await env.CACHE.list({ prefix: "attempts:" });
  const kvRows = [];
  for (const k of kvKeys.keys) {
    const raw = await env.CACHE.get(k.name);
    const userId = k.name.replace(/^attempts:/, "");
    // 解析尝试次数...
    kvRows.push({ userId, attemptsCount });
  }

  // 合并数据并返回
  return json(merged, origin);
}
```

**2. 开始尝试接口**
```typescript
if (url.pathname === "/begin" && req.method === "POST") {
  const { userId, nickname } = await req.json();
  
  const key = `attempts:${userId}`;
  const raw = await env.CACHE.get(key);
  let attempts = parseInt(raw) || 0;
  
  if (attempts >= MAX_ATTEMPTS) {
    return json({ ok: false, attemptsCount: attempts, reason: "limit" }, origin, 403);
  }
  
  attempts += 1;
  await env.CACHE.put(key, JSON.stringify({ attemptsCount: attempts, nickname }));
  return json({ ok: true, attemptsCount: attempts }, origin, 200);
}
```

**3. 提交成绩接口**
```typescript
if (url.pathname === "/submit" && req.method === "POST") {
  const { userId, nickname, moves, timeMs } = await req.json();
  
  // 数据验证
  if (!userId || !nickname || !Number.isInteger(moves) || !Number.isInteger(timeMs)) {
    return json({ error: "Missing or invalid fields" }, origin, 400);
  }
  
  if (moves <= 0 || timeMs <= 0 || nickname.length > 32) {
    return json({ error: "Bad values" }, origin, 400);
  }
  
  // 写入数据库
  const createdAt = Date.now();
  await env.DB.prepare(
    `INSERT INTO scores (user_id, nickname, moves, time_ms, created_at)
     VALUES (?, ?, ?, ?, ?)`
  ).bind(userId, nickname, moves, timeMs, createdAt).run();
  
  // 清理缓存
  await env.CACHE.delete("leaderboard:top:50").catch(() => {});
  return json({ ok: true }, origin, 201);
}
```

**4. 管理接口**
```typescript
// 清空排行榜
if (url.pathname === "/admin/clear" && req.method === "POST") {
  const { password } = await req.json();
  if (password !== ADMIN_PASSWORD) return json({ error: "Unauthorized" }, origin, 401);
  
  await env.DB.exec(`DELETE FROM scores`);
  
  const kvKeys = await env.CACHE.list({ prefix: "attempts:" });
  for (const k of kvKeys.keys) {
    await env.CACHE.delete(k.name);
  }
  
  return json({ ok: true }, origin, 200);
}

// 编辑用户
if (url.pathname === "/admin/edit" && req.method === "POST") {
  const { password, userId, nickname, moves, timeMs, attemptsCount } = await req.json();
  if (password !== ADMIN_PASSWORD) return json({ error: "Unauthorized" }, origin, 401);
  
  // 更新尝试次数
  if (typeof attemptsCount === "number" && attemptsCount >= 0) {
    await env.CACHE.put(`attempts:${userId}`, JSON.stringify({ attemptsCount, nickname }));
  }
  
  // 更新成绩
  if (Number.isInteger(moves) && Number.isInteger(timeMs)) {
    await env.DB.prepare(`DELETE FROM scores WHERE user_id = ?`).bind(userId).run();
    await env.DB.prepare(
      `INSERT INTO scores (user_id, nickname, moves, time_ms, created_at) VALUES (?, ?, ?, ?, ?)`
    ).bind(userId, nickname, moves, timeMs, Date.now()).run();
  }
  
  return json({ ok: true }, origin, 200);
}
```

## 数据流设计

### 1. 用户登录流程
```
用户输入工号+姓名 → 验证people.json → 设置currentUser → 调用/attempts获取剩余次数 → 更新UI显示
```

### 2. 游戏进行流程
```
用户点击拼图块 → 检查登录状态 → 首次移动调用/begin登记 → 启动计时 → 移动拼图块 → 检查胜利条件 → 胜利时调用/submit提交成绩 → 显示排行榜
```

### 3. 排行榜显示流程
```
点击排行榜按钮 → 调用/leaderboard接口 → 合并D1成绩和KV尝试次数 → 前端排序渲染 → 高亮当前用户
```

## 关键配置

### 前端配置
```javascript
const WORKER_BASE_URL = 'https://huarongdaoapi.biboran.top';
```

### 后端配置 (wrangler.toml)
```toml
name = "hl-worker"
main = "src/index.ts"
compatibility_date = "2025-09-16"

[[d1_databases]]
binding = "DB"
database_name = "hl_leaderboard"
database_id = "e858d846-53d1-46fa-9507-1840e4e7d8cb"

[[kv_namespaces]]
binding = "CACHE"
id = "728c6d1b94e64ec694f51d08c5361ff6"

[vars]
ALLOWED_ORIGINS = "https://liqunhuarongdao.biboran.top"
```

## 可复用组件

### 1. 用户认证模块
- 基于JSON文件的简单用户验证
- 可替换为数据库或第三方认证

### 2. 计时系统
- 精确到毫秒的计时器
- 支持暂停、重置、格式化显示

### 3. 排行榜系统
- 多维度排序（时间、步数）
- 实时数据更新
- 用户高亮显示

### 4. 尝试次数管理
- 基于KV的分布式计数
- 防重复提交机制

### 5. 管理后台
- 密码保护
- 数据导出功能
- 用户数据编辑

## 部署说明

### 1. 前端部署
- 上传到Cloudflare Pages或任何静态托管服务
- 确保CORS配置正确

### 2. 后端部署
```bash
# 安装依赖
npm install

# 创建D1数据库
wrangler d1 create hl_leaderboard

# 创建KV命名空间
wrangler kv:namespace create "CACHE"

# 运行数据库迁移
wrangler d1 execute hl_leaderboard --file=./schema.sql

# 部署Worker
wrangler deploy
```

### 3. 环境变量配置
- 在wrangler.toml中配置D1和KV绑定
- 设置ALLOWED_ORIGINS为实际前端域名

## 扩展建议

### 1. 游戏玩法扩展
- 支持不同尺寸的拼图（4×4、5×5等）
- 添加音效和动画效果
- 支持自定义图片

### 2. 功能增强
- 添加游戏历史记录
- 支持多人实时对战
- 添加成就系统

### 3. 技术优化
- 添加Redis缓存层
- 实现WebSocket实时更新
- 添加监控和日志系统

## 总结

这个华容道游戏实现了一个完整的Web游戏系统，包含用户管理、游戏逻辑、排行榜、管理后台等核心功能。代码结构清晰，模块化程度高，易于扩展和复用。通过Cloudflare Worker + D1 + KV的技术栈，实现了高性能、低成本的部署方案。

对于其他游戏项目，可以复用其中的用户认证、排行榜、计时、管理后台等模块，只需要替换具体的游戏逻辑部分即可。
